\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1\\По курсу дискрeтного анализа: сортировка за линейное время}

Выполнил студент группы 08-207 МАИ \textit{Чекменев Вячеслав Алексеевич}.

\subsection*{Условие}
\begin{itemize}
    \item Требуется разработать программу, осуществляющую ввод пар «ключ-значение», их упорядочивание по возрастанию ключа указанным алгоритмом сортировки за линейное время и вывод отсортированной последовательности.
    \item Вариант задания определяется типом ключа (и соответствующим ему методом сортировки) и типом значения:
    \item Тип ключа: почтовые индексы.
    
    \item Тип значения: числа от 0 до $2^{64} - 1$
    
\end{itemize}

\subsection*{Метод решения}

примерное описание алгоритма:
\begin{enumerate}
    \item заполнить массив префиксов так, чтобы число n, стоящее в индексе i встречается n раз в исходном массиве
    \item для того же массива - на i-е место поставить такое число $m_i$, что $m_i = m_i + m_{i-1}$
    \item затем создаем массив, который будет хранить отсортированный исходный вектор
    \item проходим справа налево по исходному массиву, берем число n и рассматриваем его как индекс для массива префиксов, получаем по нему значение, это и есть индекс нашего числа n в отсортированном массиве (только нужно сместиться влево)
\end{enumerate}

\subsection*{Описание программы}

Разделил программу на четыре файла:
\begin{itemize}
    \item заголовочный файл TDataItem.hpp содержит описание структуры данных и подключение библиотек
    \item заголовочный файл TData.hpp содержит описание класса, который обеспечивает работу с вектором структур из TDataItem.hpp
    \item файл TData.cpp содержит описание методов соответствующего класса
    \item файл main.cpp программа-драйвер
\end{itemize}

\subsection*{Дневник отладки}
\begin{enumerate}
    \item не прохожу 1 тест  - ML, решил сразу. Решение: скинул весь код в один файл, все нормализовалось
    \item не прохожу 3 тест  - RE, неделю не мог решить. Решение: нужно было проверить первую строку на пустоту. Написал рандом тесты на питоне, увидел, что возникает std::length exception, когда первая строка пуста. В итоге завел глоб переменную, есть заходил в цикл считывания строк, то ставил true, иначе оставалось false.
    \item не прохожу 13 тест - TL, решил сразу. Решение: изменил тип uint64\_t на uint\_fast64\_t, отключил синхронизацию с stdio.h, что-то из этого сработало, не узнавал, что именно.
\end{enumerate}


\subsection*{Тест производительности}

Создал три файла с данными, размеры и время выполнения:
\begin{enumerate}
    \item $10^4$ строк -- 0,075 (сек) 
    \item $10^5$ строк -- 0,638 (сек)
    \item $10^6$ строк -- 5,900 (сек)
\end{enumerate}
Как видно, сложность можно оченить сверху линией

\subsection*{Недочёты}

Вывод ведущих нулей можно было бы сделать более эффективным способом, а я сделал с помощью средств библиотеки iomanip. Хотелось бы все-таки отослать на чекер программу с make, но тратить на это время нет смысла, так как код сам по себе несложный.

\subsection*{Выводы}
\begin{itemize}
\item Сортировка подсчетом используется для набора данных, где $\delta =$ maxNumber - minNumber соответствует размерам памяти, которую можно выделить для массива. Если же колебание будет чересчур большим, то придется тратить много памяти. В моем случае этот алгоритм подходит, можно сказать, идеально.
\item Если говорить о сложности именно написания алгоритма, то это было очень просто, однако сложнее оказалось (как всегда) отловить экстремальные случаи, например, пустую первую строку или очень большое количество строк во входных данных.
\item Могу еще упомянуть занятность данного рода алгоритмов (за линейное время). Очень интересно решать задачу не напрямую, как в базовых сортировках. Не скажу, что это было для меня открытием, так как мы проходили эти сортировки ещ на первом курсе, однако написать их самостоятельно было очень увлекательно.
\end{itemize}

\end{document}

